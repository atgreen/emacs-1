* About

This is my Emacs configuration, assembled over the course of more than ten years. I first started using Emacs in earnest my sophomore year of college, which would be… 2009. As of this writing, it is 2020, and I have an incurable case of Emacs-related brain worms.

Take this file, for example. It's an org-mode document, like all the posts on my blog. And if you're reading it on my blog in HTML form, it is because my blog pulls in my Emacs configuration as a submodule, and a conveniently-placed symlink means that it is treated like any other post, and its embedded code is rendered in fancy code blocks. If you're reading it on my GitHub repository, you'll see it rendered inline in the repository, as its filename is ~readme.org~. And at Emacs boot time, Emacs itself runs ~org-babel~, generates elisp code out of the code snippets embedded herein, and loads it. I feel both delight and shame in equal quantities at this state of affairs.

* Preliminaries

We have to insert an appropriate magic comment so that lexical binding is on, just in case.

#+begin_src emacs-lisp :tangle yes
;; init.el -- Patrick Thomson's emacs config. -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; This file is automatically generated from readme.org with org-babel. Don't edit it.
;; The org-babel source, and this generated code, are in the public domain.

;;; Code:
#+end_src

#+RESULTS:

We use ~use-package~ everywhere (it is loaded in ~init.el~), and by default we want it to install all mentioned packages.

#+begin_src emacs-lisp
  (setq use-package-always-ensure t)

  (use-package use-package)
#+end_src

* OS-specific concerns

Since subsequent packages like ~libgit~ may depend on executables like ~cmake~, we need to ensure that Emacs has access to the PATH associated with the current environment.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src

* Fixing broken defaults

Fixing Emacs's defaults is a nontrivial problem. We'll start with UI concerns.

#+begin_src emacs-lisp
  (setq
   inhibit-startup-screen t ; No need to see GNU agitprop.
   sentence-end-double-space nil ; You're on a computer. You don't need double-spaces.
   initial-scratch-message nil ; Emacs doesn't need to remind me what a scratch buffer is.
   ring-bell-function 'ignore ; Never ding at me, ever
   use-dialog-box nil ; The macOS dialog boxes are hideous, put them in the minibuffer
   mark-even-if-inactive nil ; fix undo in commands affecting the mark
   )

#+end_src

Text editing defaults are similarly mediocre. If your Emacs would be broken by UTF-8 becoming the default, /you're a bad person and you need to stop that/.

#+begin_src emacs-lisp
  (set-charset-priority 'unicode)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix))

  (setq
   kill-whole-line t ; Let C-k delete the whole line.
   indent-tabs-mode nil ; Mixing tabs and spaces is an abomination, but Emacs does it out of the box.
   sentence-end-double-space nil ; I'm personally offended that I have to specify this.
  )

  (defalias 'yes-or-no-p 'y-or-n-p) ; Accept 'y' in lieu of 'yes'.
#+end_src

We also need to turn on a few modes to have behavior that's even remotely modern.

#+begin_src emacs-lisp
  (delete-selection-mode t) ; I'll never know why they didn't turn this on by default.
  (global-hl-line-mode t) ; highlight the current line
  (global-display-line-numbers-mode t)
  (column-number-mode)
#+end_src

Emacs is super fond of littering filesystems with backups and autosaves, since it was built with the assumption that multiple users could be using the same Emacs instance on the same filesystem. This was valid in 1980. It is no longer the case.

#+begin_src emacs-lisp
  (setq
   make-backup-files nil
   auto-save-default nil
   create-lockfiles nil)
#+end_src

Emacs stores any configuration you make through its UI in this custom.el file. This is an excellent way to screw up your configuration because something in custom.el is overriding a variable that you're trying to set somewhere else. The ~custom-file~ variable can't be nil, but we can make it look in a different place every time.

#+begin_src emacs-lisp
(setq custom-file (make-temp-file ""))
#+end_src


#+begin_src emacs-lisp
  (setq custom-file "~/.config/emacs/custom.el")
  (load custom-file 'noerror)
#+end_src

However, because Emacs stores theme-safety information in that file, we have to disable the warnings entirely. This is not particularly secure, but if someone has uploaded malicious code to MELPA inside a theme, I have bigger problems. (Besides, Emacs is not a secure system, and I see no need to try overmuch to make it one.)

#+begin_src emacs-lisp
  (setq custom-safe-themes t)
#+end_src

recentf mode is really fond of cluttering itself up with .el autoloads.

#+begin_src emacs-lisp
  (require 'recentf)
  (add-to-list 'recentf-exclude "\\elpa")
#+end_src

Emoji don't work on Emacs versions < 27 (aside from the Mitsuharu Yamamoto emacs-mac port), and for those greater than 27 we seem to need this. A fun fact about this: that commented parenthesis is to work around an inscrutable bug that I can't reproduce in other documents.

#+begin_src emacs-lisp
  (if ( version< "27.0" emacs-version ) ; )
      (set-fontset-font "fontset-default" 'unicode "Apple Color Emoji" nil 'prepend)
    (warn "This Emacs version is too old to properly support emoji."))
#+end_src

I genuinely can't imagine having a use for ~find-file-read-only~---why am I opening Emacs if I don't want to edit text?---and it certainly doesn't deserve its own keybinding.

#+begin_src emacs-lisp
  (bind-key "C-x C-f" #'counsel-find-file)
#+end_src

The out-of-the-box treatment of whitespace is unfortunate, but fixable.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (setq require-final-newline t)
#+end_src

Emacs instances started outside the terminal do not pick up ssh-agent information unless we use keychain-environment.
Note to self: if you keep having to enter your keychain password on macOS, make sure this is in .ssh/config:

#+begin_src
Host *
  UseKeychain yes
#+end_src

#+begin_src emacs-lisp
  (use-package keychain-environment
    :config
    (keychain-refresh-environment))
#+end_src

Emacs is also in love with showing you its NEWS file; it's bound to like four different keybindings. Overriding the function makes it a no-op. You might say… no news is good news. For that matter, we can elide more GNU agitprop.

#+begin_src emacs-lisp
  (defun do-nothing (interactive))
  (defalias 'view-emacs-news 'do-nothing)
  (defalias 'describe-gnu-project 'do-nothing)
#+end_src

Undo has always been problematic for me in Emacs, and I only just learned why: a redo action marks itself as undoable. This binds a better default.

#+begin_src emacs-lisp
  (bind-key "s-y" #'undo-redo)
#+end_src

It's 2020, we don't paste with mouse-wheel-click anymore.

#+begin_src emacs-lisp
  (unbind-key "<mouse-2>")
#+end_src

* Visuals

#+begin_src emacs-lisp
  (ignore-errors (set-frame-font "SF Mono-12"))
#+end_src

Emacs looks a lot better when it has VSCode-esque icons.

#+begin_src emacs-lisp
  (use-package all-the-icons)

  (use-package all-the-icons-dired
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

Every Emacs window should, by default occupy all the screen space it can.
This doesn't appear to do what I want on Emacs 27.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Window chrome both wastes space and looks unappealing.

#+begin_src emacs-lisp
  (when (window-system)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (tooltip-mode -1)
    (fringe-mode -1))
#+end_src

I use the [[https://github.com/hlissner/emacs-doom-themes][Doom Emacs themes]], which are gorgeous.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (let ((chosen-theme 'doom-challenger-deep))
      (doom-themes-visual-bell-config)
      (doom-themes-org-config)
      (set-face-attribute 'hl-line nil :background "gray26")
      (setq doom-challenger-deep-brighter-comments t
            doom-challenger-deep-brighter-modeline t)
      (load-theme chosen-theme)))
#+end_src

Most major modes pollute the modeline, so we pull in diminish.el to quiesce them.

#+begin_src emacs-lisp
  (use-package diminish
    :config (diminish 'eldoc-mode))
#+end_src

The default modeline is pretty uninspiring, and doom-modeline doesn't appear to be particularly slow.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :config (doom-modeline-mode))
#+end_src

I find it useful to have a slightly more apparent indicator of which buffer is active at the moment.

#+begin_src emacs-lisp
  (use-package dimmer
    :custom (dimmer-fraction 0.1)
    :config (dimmer-mode))
#+end_src

** Tabs

The long-awaited Emacs 27 support for native tabs is shaky, both visually and in terms of functionality. As such, ~centaur-tabs~ is the best way forwards.

#+begin_src emacs-lisp
  (use-package centaur-tabs
    :demand
    :config
    (centaur-tabs-mode t)
    :custom
    (centaur-tabs-gray-out-icons 'buffer)
    (centaur-tabs-style "rounded")
    (centaur-tabs-height 36)
    (centaur-tabs-set-icons t)
    (centaur-tabs-set-modified-marker t)
    (centaur-tabs-modified-marker "●")
    (centaur-tabs-buffer-groups-function #'centaur-tabs-projectile-buffer-groups)

    :bind (("s-{" . #'centaur-tabs-backward)
	   ("s-}" . #'centaur-tabs-forward)))
#+end_src

* Text manipulation

Any modern editor should include multiple-cursor support. Sure, keyboard macros would suffice, sometimes. Let me live. I haven't yet taken advantage of many of the ~multiple-cursors~ commands. Someday.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind (("C-c m m" . #'mc/edit-lines )
           ("C-c m d" . #'mc/mark-all-dwim )))
#+end_src

I know I'm repeating myself re. the inadequacy of stock Emacs defaults, but lack of parenthesis-matching is pretty egregious. It even comes with ~electric-pair-mode~, which is not turned on by default, even in ~prog-mode.~

#+begin_src emacs-lisp
  (use-package smartparens
    :config (smartparens-global-mode))
#+end_src

Textmate-style tap-to-expand-into-the-current-delimiter is very useful and curiously

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-c n" . er/expand-region)))
#+end_src


I'm not interested in calling anything associated with ~facemenu-mode~.

#+begin_src emacs-lisp
  (unbind-key "M-o")
#+end_src

* Buffer management

Bufler is a new addition here; I'm still not 100% sold, but given that I work on an ultra-widescreen monitor, I need to start figuring out some better buffer layout mechanism, because the situation is not particularly good.

#+begin_src emacs-lisp
  (use-package bufler
    :bind (("C-x b" . #'bufler-switch-buffer)))
#+end_src

I almost always want to default to a two-buffer setup.

#+begin_src emacs-lisp
  (defun revert-to-two-windows ()
    "Delete all other windows and split it into two."
    (interactive)
    (delete-other-windows)
    (split-window-right))

  (bind-key "C-x 1" #'revert-to-two-windows)
  (bind-key "C-x !" #'delete-other-windows) ;; Access to the old keybinding.
#+end_src

Ivy makes ~kill-buffer~ give you a list of possible results, which isn't generally what I want.

#+begin_src emacs-lisp
  (defun kill-this-buffer ()
    "Kill the current buffer."
    (interactive)
    (kill-buffer nil)
    )

  (bind-key "C-x k" #'kill-this-buffer)
  (bind-key "C-x K" #'kill-buffer)
#+end_src

VS Code has a great feature where you can just copy a filename to the clipboard.

#+begin_src emacs-lisp
  (defun copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
			default-directory
		      (buffer-file-name))))
      (when filename
	(kill-new filename)
	(message "Copied buffer file name '%s' to the clipboard." filename))))

  (bind-key "C-c P" #'copy-file-name-to-clipboard)
#+end_src

Normally I bind ~other-window~ to ~C-c ,~, but on my ultra-wide-screen monitor, which supports up to 8 buffers comfortably, holding that key to move around buffers is kind of a drag. Some useful commands to remember here are ~aw-ignore-current~ and ~aw-ignore-on~.

#+begin_src emacs-lisp
  (use-package ace-window
    :config
    ;; Show the window designators in the modeline.
    (ace-window-display-mode)

     ;; Make the number indicators a little larger. I'm getting old.
    (set-face-attribute 'aw-leading-char-face nil :height 2.0 :background "black")

    (defun my-ace-window (args)
      "As ace-window, but hiding the cursor while the action is active."
      (interactive "P")
      (cl-letf ((cursor-type nil)
		(cursor-in-non-selected-window nil))
	(ace-window nil)))


    :bind (("C-," . my-ace-window))
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l) "Designate windows by home row keys, not numbers.")
    (aw-background nil))
#+end_src

* Quality-of-life improvements

We start by binding a few builtin commands to more-convenient keystrokes.

#+begin_src emacs-lisp
  (bind-key "C-c 3" #'split-window-right)
#+end_src

Given how often I tweak my config, I bind ~C-c e~ to take me to my config file.

#+begin_src emacs-lisp
  (defun open-init-file ()
    "Open this very file."
    (interactive)
    (find-file "~/.config/emacs/readme.org"))

  (bind-key "C-c e" #'open-init-file)
#+end_src

Emacs makes it weirdly hard to just, like, edit a file as root. Enter ~sudo-edit~.

#+begin_src emacs-lisp
  (use-package sudo-edit)
#+end_src

By default, Emacs uses a new buffer for every directory you visit in dired. This is not only terrible from a UI perspective---Emacs warns you if you try to use the sensible behavior (the ~a~ key, ~dired-find-alternate-file~). Willfully obtuse. The ~dired+.el~ library fixes this, but because it's not on MELPA, I refuse to use it out of principle (this man's refusal to compromise is nothing short of crankery, and it would be intellectually remiss of me to abet his crankery). But, as always, we can make Emacs do the right thing. Manually.

#+begin_src emacs-lisp
  (defun dired-up-directory-same-buffer ()
    "Go up in the same buffer."
    (find-alternate-file ".."))

  (defun my-dired-mode-hook ()
    (put 'dired-find-alternate-file 'disabled nil) ; Disables the warning.
    (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
    (define-key dired-mode-map (kbd "^") 'dired-up-directory-same-buffer))

  (add-hook 'dired-mode-hook #'my-dired-mode-hook)
#+end_src

Emacs has problems with very long lines. ~so-long~ detects them and takes appropriate action. Good for minified code and whatnot.

#+begin_src emacs-lisp
  (global-so-long-mode)
#+end_src

Using an ephemeral buffer to indicate what commands are available makes discovering functionality a breeze.

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode)
    (which-key-setup-side-window-bottom)
    :custom (which-key-idle-delay 2))
#+end_src

I've never needed a font panel in Emacs, not even once.

#+begin_src emacs-lisp
  (unbind-key "s-t")
#+end_src

It's genuinely shocking that there's no "duplicate whatever's marked" command built-in.

#+begin_src emacs-lisp
  (use-package duplicate-thing
    :bind (("C-c u" . duplicate-thing)))
#+end_src

We need to support reading large blobs of data for LSP's sake.

#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024)) ; 1mb
#+end_src

When I hit, accidentally or purposefully, a key chord that forms the prefix of some other chords, I want to see a list of possible completions and their info.

#+begin_src emacs-lisp
  (use-package which-key
    :custom
    (which-key-setup-side-window-bottom)
    (which-key-enable-extended-define-key t)
    :config
    (which-key-setup-minibuffer))
#+end_src

* Org-mode

#+begin_src emacs-lisp
  (use-package org
    :hook ((org-mode . visual-line-mode))
    :bind (:map org-mode-map
		("C-c c" . #'org-mode-insert-code)
		("C-c a f" . #'org-shifttab))
    :custom
    (org-return-follows-link t)
    (org-src-ask-before-returning-to-edit-buffer nil)

    :config
    ;; Putting these in a loop or in :bind generates invalid code and I have no idea why.
    (unbind-key "C-," org-mode-map)
    (unbind-key "C-c ;" org-mode-map)
    (unbind-key "C-c ," org-mode-map)

    (defun org-mode-insert-code ()
      (interactive)
      (org-emphasize ?~)))

  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
#+end_src

* Projectile

Most every nontrivial package provides projectile integration in some form or fashion.

#+begin_src emacs-lisp
  (use-package projectile
    :diminish
    :bind (("C-c k" . #'projectile-kill-buffers)
	   ("C-c M" . #'projectile-compile-project))
    :custom (projectile-completion-system 'ivy)
    :config (projectile-mode))
#+end_src

* Ivy, counsel, and swiper

"Should I use Helm or Ivy?" It's one of the biggest questions everyone with a nice Emacs setup has to answer. Helm is more featureful and fancier out of the box, whereas Ivy is more minimal, requiring a few packages to approach how nice Helm looks. However, Ivy is still worth it to me, given that I spend a lot of time cursing Emacs's performance on macOS. And with ~ivy-rich~, things even look nice.

#+begin_src emacs-lisp
  (use-package ivy
    :diminish
    :custom
    (ivy-height 30)
    (ivy-use-virtual-buffers t)
    (ivy-use-selectable-prompt t)
    :config
    (ivy-mode 1)

    :bind (("C-c C-r" . #'ivy-resume)
           ("C-c s"   . #'swiper-thing-at-point)
           ("C-s"     . #'swiper)))

  (use-package ivy-rich
    :custom
    (ivy-virtual-abbreviate 'full)
    (ivy-rich-switch-buffer-align-virtual-buffer nil)
    (ivy-rich-path-style 'full)
    :config
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    (ivy-rich-mode))

  (use-package counsel
    :init
    (counsel-mode 1)

    :bind (("C-c ;" . #'counsel-M-x)
           ("C-c U" . #'counsel-unicode-char)
           ("C-c i" . #'counsel-imenu)
           ("C-x f" . #'counsel-find-file)
           ("C-c y" . #'counsel-yank-pop)
           ("C-c r" . #'counsel-recentf)
           ("C-c v" . #'counsel-switch-buffer-other-window)
           ("C-h h" . #'counsel-command-history)
           :map ivy-minibuffer-map
           ("C-r" . counsel-minibuffer-history))
    :diminish)

  (use-package counsel-projectile
    :bind (("C-c f" . #'counsel-projectile)
           ("C-c F" . #'counsel-projectile-switch-project)))

  (use-package smex)
#+end_src

* Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :after org
    :hook (org-src-mode . disable-flycheck-for-elisp)
    :custom
    (flycheck-emacs-lisp-initialize-packages t)
    :config
    (global-flycheck-mode)

    (defun disable-flycheck-for-elisp ()
      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

    (add-to-list 'flycheck-checkers 'proselint))

  (use-package flycheck-inline)

#+end_src

* Searching

deadgrep is the bee's knees for project-wide search, as it uses ~ripgrep~.

#+begin_src emacs-lisp
  (use-package deadgrep
    :bind (("C-c h" . #'deadgrep)))
#+end_src

I remember the days before Emacs had real regular expressions. Nowadays, we have them, but the find-and-replace UI is bad. ~visual-regexp~ fixes this. I have this bound to an incredibly stupid keybinding because I simply do not want to take the time to catabolize/forget that particular muscle memory

#+begin_src emacs-lisp
  (use-package visual-regexp
    :bind (("C-c 5" . #'vr/replace)))
#+end_src

* Autocomplete

Completion in Emacs is sort of a fraught enterprise, given the existence of ~pcomplete~, ~hippie-expand~, and ~complete.el~. ~company~ is the least problematic and most modern of these alternatives, though it's kind of a bear to configure. Its interface is not so nice by default but all the frontends flicker terribly if you're typing quickly, which is just spectacularly distracting.

TODO: C-n and C-p should work in the company completion map, but I'm so tired of wrestling with company that I truly don't care.

#+begin_src emacs-lisp
  (use-package company
    :diminish
    :bind (("C-." . #'company-complete))
    :hook (prog-mode . company-mode)
    :custom
    (company-dabbrev-downcase nil "Don't downcase returned candidates.")
    (company-show-numbers t "Numbers are helpful.")
    (company-tooltip-limit 20 "The more the merrier.")
    (company-idle-delay 0.1 "Faster!")
    (company-async-timeout 20 "Some requests can take a long time. That's fine.")
    :config

    ;; Use the numbers 0-9 to select company completion candidates
    (let ((map company-active-map))
      (mapc (lambda (x) (define-key map (format "%d" x)
			  `(lambda () (interactive) (company-complete-number ,x))))
	    (number-sequence 0 9))))
#+end_src

* Magit

Magit is one of the top three reasons anyone should use Emacs. What a brilliant piece of software it is. I never thought I'd be faster with a git GUI than with the command line, since I've been using git for 13 years at this point, but wonders really never cease. Magit is as good as everyone says, and more.

#+begin_src emacs-lisp
  (use-package magit
    :diminish magit-auto-revert-mode
    :diminish auto-revert-mode
    :bind (("C-c g" . #'magit-status))
    :config)


  (use-package libgit)

  (use-package magit-libgit
    :after (magit libgit))
#+end_src

* LSP

Before Emacs 27, the LSP experience on large projects was not particularly good. We now have native JSON parsing support. I am told that it makes things easier.



#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-execute-code-action)
    :hook ((go-mode . lsp-deferred)
	   (lsp-mode . lsp-enable-which-key-integration)
	   (lsp-mode . lsp-diagnostics-modeline-mode))
    :bind ("C-c C-c" . #'lsp-execute-code-action)
    :custom
    (lsp-print-performance t)
    (lsp-log-io t)
    (lsp-diagnostics-modeline-scope :project))

  (use-package lsp-ui
    :custom (lsp-ui-doc-delay 0.75)
    :after lsp-mode)

  (use-package lsp-ivy
    :after (ivy lsp-mode))

  (use-package company-lsp
    :custom (company-lsp-enable-snippet t)
    :after (company lsp-mode))
#+end_src

* Haskell

Haskell is my day-to-day programming language, so I've tinkered with it a good deal. Featuring automatic ~ormolu~ or ~stylish-haskell~ invocation, as based on a per-project variable, so I can default to ~ormolu~ but choose ~stylish-haskell~ for the projects that don't.

#+begin_src emacs-lisp
  (use-package haskell-mode

    :config
    (defvar haskell-formatter 'ormolu
      "The Haskell formatter to use. One of: 'ormolu, 'stylish, nil. Set it per-project in .dir-locals.")

    (defun haskell-smart-format ()
      "Format a buffer based on the value of 'haskell-formatter'."
      (interactive)
      (cl-ecase haskell-formatter
	('ormolu (ormolu-format-buffer))
	('stylish (haskell-mode-stylish-buffer))
	(nil nil)
	))

    (defun haskell-switch-formatters ()
      "Switch from ormolu to stylish-haskell, or vice versa."
      (interactive)
      (setq haskell-formatter
	    (cl-ecase haskell-formatter
	      ('ormolu 'stylish)
	      ('stylish 'ormolu)
	      (nil nil))))

    :bind (("C-c a c" . haskell-cabal-visit-file)
	   ("C-c a i" . haskell-navigate-imports)
	   ("C-c a I" . haskell-navigate-imports-return)))

  (use-package haskell-snippets
    :after (haskell-mode yasnippet)
    :defer)
#+end_src

~haskell-language-server~ is the new hotness, but it doesn't appear to handle autocompletion properly, so ~haskell~ide~engine~ it is.

#+begin_src emacs-lisp
  (use-package lsp-haskell
    :hook (haskell-mode . lsp)
    :custom (lsp-haskell-process-path-hie "hie-wrapper")
    )
#+end_src

My statements about Haskell autoformatters have, in the past, attracted controversy, so I have no further comment on the below lines. Note that ~haskell-lsp~ runs ormolu with ~lsp-format-buffer~.

#+begin_src emacs-lisp
  (use-package ormolu)
#+end_src

* vterm

The state of terminal emulation is, as a whole, a mess. The only recent bright spot has been libvterm, which, when integrated with Emacs's new dynamic module support, enables us to have a very, very fast terminal inside Emacs.

A thing I want to do someday is to write a framework for sending things like compile commands to a running vterm buffer with ~vterm-send-string~.

#+begin_src emacs-lisp
  (use-package vterm)

  (use-package vterm-toggle
    :custom
    (vterm-toggle-fullscreen-p nil "Open a vterm in another window.")
    :bind (("C-c t" . #'vterm-toggle-cd)
	   :map vterm-mode-map
	   ("<C-return>" . #'vterm-toggle-insert-cd)))
#+end_src

* Process management

~prodigy~ is a great and handsome frontend for managing long-running services. Since many of the services I need to run are closed-source, the calls to ~prodigy-define-service~ are located in an adjacent file. Unfortunately, ~prodigy~ doesn't really have any good support for managing Homebrew services. Maybe I'll write one, in my copious spare time.

#+begin_src emacs-lisp
  (use-package prodigy
    :bind ("C-c 8" . #'prodigy)
    :config
    (load "~/.config/emacs/services.el" 'noerror))
#+end_src

* Snippets

I grew up writing in TextMate, so I got extremely used to text-expansion snippets. I also think they're extremely underrated for learning a new language's idioms: one of the reasons I was able to get up to speed so fast with Rails (back in the 1.2 days) was because the TextMate snippets indicated pretty much everything you needed to know about things like ActiveRecord.

#+begin_src emacs-lisp
  (use-package yasnippet
    :defer 3 ;; takes a while to load, so do it async
    :diminish yas-minor-mode
    :config (yas-global-mode)
    :custom (yas-prompt-functions '(yas-completing-prompt)))
#+end_src

* Other Languages

** General-purpose

I occasionally write Go, generally as a glue language to munge things together. I find ertain aspects of its creators' philosophies to be repellent, but it's hard to argue with the success it's found in industry.

#+begin_src emacs-lisp
  (use-package go-mode
    :config
    (add-hook 'before-save-hook #'gofmt-before-save))

  (use-package go-snippets)
#+end_src

** Configuration

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

** Interchange

#+begin_src emacs-lisp
(use-package protobuf-mode)
#+end_src

** Markup

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode ("\\.md$" . gfm-mode))
#+end_src

** Shell

#+begin_src emacs-lisp
  (use-package fish-mode)
#+end_src

* Miscellany

~restclient~ is a terrific interface for running HTTP requests against local or remote services.

#+begin_src emacs-lisp
(use-package restclient
  :mode ("\\.restclient$" . restclient-mode))
#+end_src
